# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, FIRST and other WPILib Contributors
# This file is distributed under the same license as the FIRST Robotics Competition package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Jiangshan Gong <jiangshan_gong@163.com>, 2020
# Tianrui Wu <tw2789@columbia.edu>, 2020
# Emma Yuan <emmayyw@gmail.com>, 2020
# Yitong Zhao <lucius300er@outlook.com>, 2021
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: FIRST Robotics Competition 2021\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-02-16 16:17+0000\n"
"PO-Revision-Date: 2020-04-25 02:02+0000\n"
"Last-Translator: Yitong Zhao <lucius300er@outlook.com>, 2021\n"
"Language-Team: Chinese (China) (https://www.transifex.com/wpilib/teams/109324/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../frc-docs/source/docs/software/commandbased/what-is-command-based.rst:2
msgid "What Is \"Command-Based\" Programming?"
msgstr "什么是 \"Command-Based\" 编程？"

#: ../../frc-docs/source/docs/software/commandbased/what-is-command-based.rst:20
msgid ""
"In contrast, in an ordinary `imperative "
"<https://en.wikipedia.org/wiki/Imperative_programming>`__ program, the user "
"would need to check the button state every iteration, and perform the "
"appropriate action based on the state of the button."
msgstr ""
"相反，在普通的`imperative "
"<https://en.wikipedia.org/wiki/Imperative_programming>`__程序中，用户将需要在每次迭代时检查按钮状态，并根据按钮的状态执行适当的操作。"

#: ../../frc-docs/source/docs/software/commandbased/what-is-command-based.rst:47
msgid "Subsystems and Commands"
msgstr "子系统和指令"

#: ../../frc-docs/source/docs/software/commandbased/what-is-command-based.rst:52
msgid ""
"The command-based pattern is based around two core abstractions: "
"**commands**, and **subsystems.**"
msgstr "基于命令的编程模式基于两个核心抽象类：**指令**和**子系统。**"

#: ../../frc-docs/source/docs/software/commandbased/what-is-command-based.rst:59
msgid "How Commands Are Run"
msgstr "指令如何运行"

#: ../../frc-docs/source/docs/software/commandbased/what-is-command-based.rst:61
msgid "For a more detailed explanation, see :doc:`command-scheduler`."
msgstr "有关更详细的说明，请参考:doc:`command-scheduler`.。"

#: ../../frc-docs/source/docs/software/commandbased/what-is-command-based.rst:63
msgid ""
"Commands are run by the ``CommandScheduler`` (`Java "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/CommandScheduler.html>`__,"
" `C++ "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/cpp/classfrc2_1_1CommandScheduler.html>`__),"
" a singleton class that is at the core of the command-based library. The "
"``CommandScheduler`` is in charge of polling buttons for new commands to "
"schedule, checking the resources required by those commands to avoid "
"conflicts, executing currently-scheduled commands, and removing commands "
"that have finished or been interrupted. The scheduler’s ``run()`` method may"
" be called from any place in the user’s code; it is generally recommended to"
" call it from the ``robotPeriodic()`` method of the ``Robot`` class, which "
"is run at a default frequency of 50Hz (once every 20ms)."
msgstr ""
"命令由CommandScheduler（Java "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/CommandScheduler.html>`__，`C"
" ++ "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/cpp/classfrc2_1_1CommandScheduler.html>`__）运行，这是基于命令的库的核心的单例类。"
" "
"CommandScheduler负责轮询按钮以安排新命令，检查这些命令所需的资源以避免冲突，执行当前已调度的命令以及删除已完成或已中断的命令。可以在用户代码中的任意位置调用调度程序的run（）方法；通常建议从“"
" Robot”类的“ robotPeriodic（）”方法调用它，该方法以默认频率50Hz（每20ms一次）运行。"

#: ../../frc-docs/source/docs/software/commandbased/what-is-command-based.rst:65
msgid ""
"Multiple commands can run concurrently, as long as they do not require the "
"same resources on the robot. Resource management is handled on a per-"
"subsystem basis: commands may specify which subsystems they interact with, "
"and the scheduler will never schedule more than one command requiring a "
"given subsystem at a time. This ensures that, for example, users will not "
"end up with two different pieces of code attempting to set the same motor "
"controller to different output values. If a new command is scheduled that "
"requires a subsystem that is already in use, it will either interrupt the "
"currently-running command that requires that subsystem (if the command has "
"been scheduled as interruptible), or else it will not be scheduled."
msgstr ""
"只要这些指令不需要“Robot”类中的相同资源，就可以同时运行多个指令。资源管理是在每个子系统的基础上进行的：指令可以指定与之交互的子系统，并且调度程序每一次运行都只会调度一个需要一个特定子类的指令。这样可以确保一种情况，例如，用户不会以试图将同一电动机控制器设置为不同输出值的两个不同的代码结尾。如果调度了一个需要已在使用的子系统的新指令，则它将中断需要该子系统的当前正在运行的指令（如果该指令已被安排为可中断），否则前者将不会被调度。"

#: ../../frc-docs/source/docs/software/commandbased/what-is-command-based.rst:69
msgid ""
"When a command is scheduled, its ``initialize()`` method is called once. Its"
" ``execute()`` method is then called once per call to "
"``CommandScheduler.getInstance().run()``. A command is un-scheduled and has "
"its ``end(boolean interrupted)`` method called when either its "
"``isFinished()`` method returns true, or else it is interrupted (either by "
"another command with which it shares a required subsystem, or by being "
"canceled)."
msgstr ""
"调度一个指令后，其“initialize()”方法将被调用一次。然后，每次调用“CommandScheduler.getInstance.run()”时都会调用其“execute()”方法。当指令的“isFinished()”方法返回true或该指令被打断（被另一个使用相同子系统的指令打断或被取消）时，该指令将取消调度并调用其“end(boolean"
" interrupted)”方法。"

#: ../../frc-docs/source/docs/software/commandbased/what-is-command-based.rst:72
msgid "Command Groups"
msgstr "指令组"

#: ../../frc-docs/source/docs/software/commandbased/what-is-command-based.rst:77
msgid "Creating a Robot Project"
msgstr "创建一个机器人项目"

#: ../../frc-docs/source/docs/software/commandbased/what-is-command-based.rst:79
msgid ""
"Creating a project is detailed in :ref:`docs/software/vscode-overview"
"/creating-robot-program:Creating a Robot Program`. Select \"Template\" then "
"your programming language then \"New Command Robot\" to create a basic "
"Command-Based Robot program."
msgstr ""
"在:ref:`docs/software/vscode-overview/creating-robot-program:Creating a Robot"
" Program`中详细介绍了创建项目。选择“模板”，然后选择您的编程语言，然后选择“新指令机器人”，以创建一个基于命令的基本机器人程序。"

#: ../../frc-docs/source/docs/software/commandbased/what-is-command-based.rst:81
msgid ""
"When you create a New Command Robot project, the new command based vendor "
"library is automatically imported. If you imported a 2019 project or created"
" a different type of project, the old command library is imported, and it is"
" necessary to import the new command based vendor library per "
":doc:`/docs/software/vscode-overview/3rd-party-libraries` and remove the old"
" command library."
msgstr ""
"当使用 \"New Command Robot\" 创建新项目时，基于命令的新供应商库将被自动导入。如果您导入了 2019 "
"年的项目或创建了其他类型的项目，则将导入旧的命令库，并且有必要根据 :doc:`/docs/software/vscode-overview/3rd-"
"party-libraries` 导入基于命令的新供应商库并删除旧的指令库。"
